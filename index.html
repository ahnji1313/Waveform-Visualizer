<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>고퀄리티 스펙트로그램 생성기</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
            font-size: 0.95em;
        }

        input[type="file"],
        select,
        input[type="range"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="file"]:hover,
        select:hover {
            border-color: #667eea;
        }

        input[type="range"] {
            padding: 0;
            height: 40px;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        button {
            padding: 15px 30px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .canvas-container {
            background: #000;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            overflow: auto;
        }

        canvas {
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
            border-radius: 10px;
        }

        .info-panel {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 5px solid #2196f3;
        }

        .info-panel h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .info-panel p {
            color: #555;
            line-height: 1.6;
            margin: 5px 0;
        }

        .range-value {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 600;
            margin-left: 10px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }
            
            .container {
                padding: 20px;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎵 고퀄리티 스펙트로그램 생성기</h1>
        <p class="subtitle">오디오를 업로드하거나 녹음하여 고해상도 스펙트로그램을 생성하세요</p>

        <div class="controls">
            <div class="control-group">
                <label>오디오 파일 선택</label>
                <input type="file" id="audioFile" accept="audio/*">
            </div>

            <div class="grid-container">
                <div class="control-group">
                    <label>FFT 크기 (해상도)</label>
                    <select id="fftSize">
                        <option value="1024">1024 - 빠름</option>
                        <option value="2048">2048 - 보통</option>
                        <option value="4096" selected>4096 - 고해상도</option>
                        <option value="8192">8192 - 매우 높음</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>컬러맵</label>
                    <select id="colormap">
                        <option value="viridis" selected>Viridis</option>
                        <option value="plasma">Plasma</option>
                        <option value="inferno">Inferno</option>
                        <option value="magma">Magma</option>
                        <option value="hot">Hot</option>
                        <option value="cool">Cool</option>
                        <option value="rainbow">Rainbow</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>스펙트로그램 타입</label>
                    <select id="spectrogramType">
                        <option value="linear">Linear (선형)</option>
                        <option value="mel" selected>Mel Scale (멜 스케일)</option>
                        <option value="log">Log Scale (로그)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>최소 주파수 (Hz) <span class="range-value" id="minFreqValue">20</span></label>
                    <input type="range" id="minFreq" min="0" max="200" value="20" step="10">
                </div>

                <div class="control-group">
                    <label>최대 주파수 (Hz) <span class="range-value" id="maxFreqValue">20000</span></label>
                    <input type="range" id="maxFreq" min="8000" max="22050" value="20000" step="100">
                </div>

                <div class="control-group">
                    <label>이미지 너비 (px) <span class="range-value" id="widthValue">2048</span></label>
                    <input type="range" id="imageWidth" min="1024" max="4096" value="2048" step="128">
                </div>
            </div>

            <div class="button-group">
                <button class="btn-secondary" id="recordBtn">🎤 녹음 시작</button>
                <button class="btn-primary" id="generateBtn">✨ 스펙트로그램 생성</button>
                <button class="btn-success" id="downloadBtn" disabled>💾 이미지 다운로드</button>
            </div>
        </div>

        <div class="info-panel" id="infoPanel" style="display: none;">
            <h3>📊 오디오 정보</h3>
            <p id="audioInfo"></p>
        </div>

        <div class="canvas-container">
            <canvas id="spectrogramCanvas"></canvas>
        </div>
    </div>

    <script>
        let audioContext;
        let audioBuffer;
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        const audioFileInput = document.getElementById('audioFile');
        const generateBtn = document.getElementById('generateBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const recordBtn = document.getElementById('recordBtn');
        const canvas = document.getElementById('spectrogramCanvas');
        const ctx = canvas.getContext('2d');
        const infoPanel = document.getElementById('infoPanel');
        const audioInfo = document.getElementById('audioInfo');

        // Range 값 업데이트
        ['minFreq', 'maxFreq', 'imageWidth'].forEach(id => {
            const input = document.getElementById(id);
            const display = document.getElementById(id + 'Value');
            input.addEventListener('input', () => {
                display.textContent = input.value;
            });
        });

        // 오디오 파일 로드
        audioFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const arrayBuffer = await file.arrayBuffer();
                await loadAudioBuffer(arrayBuffer);
            }
        });

        // 녹음 기능
        recordBtn.addEventListener('click', async () => {
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    recordedChunks = [];

                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            recordedChunks.push(e.data);
                        }
                    };

                    mediaRecorder.onstop = async () => {
                        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                        const arrayBuffer = await blob.arrayBuffer();
                        await loadAudioBuffer(arrayBuffer);
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.textContent = '⏹️ 녹음 중지';
                    recordBtn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)';
                } catch (err) {
                    alert('마이크 접근 권한이 필요합니다: ' + err.message);
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.textContent = '🎤 녹음 시작';
                recordBtn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
            }
        });

        async function loadAudioBuffer(arrayBuffer) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            try {
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                generateBtn.disabled = false;
                
                // 오디오 정보 표시
                const duration = audioBuffer.duration.toFixed(2);
                const sampleRate = audioBuffer.sampleRate;
                const channels = audioBuffer.numberOfChannels;
                
                audioInfo.innerHTML = `
                    재생 시간: ${duration}초 | 
                    샘플레이트: ${sampleRate}Hz | 
                    채널: ${channels}
                `;
                infoPanel.style.display = 'block';
                
                alert('오디오 로드 완료! 스펙트로그램 생성 버튼을 클릭하세요.');
            } catch (err) {
                alert('오디오 디코딩 실패: ' + err.message);
            }
        }

        // 컬러맵 함수들
        const colormaps = {
            viridis: (t) => {
                const colors = [
                    [68, 1, 84], [72, 40, 120], [62, 73, 137], [49, 104, 142],
                    [38, 130, 142], [31, 158, 137], [53, 183, 121], [109, 205, 89],
                    [180, 222, 44], [253, 231, 37]
                ];
                return interpolateColor(colors, t);
            },
            plasma: (t) => {
                const colors = [
                    [13, 8, 135], [84, 2, 163], [139, 10, 165], [185, 50, 137],
                    [219, 92, 104], [244, 136, 73], [254, 188, 43], [240, 249, 33]
                ];
                return interpolateColor(colors, t);
            },
            inferno: (t) => {
                const colors = [
                    [0, 0, 4], [40, 11, 84], [101, 21, 110], [159, 42, 99],
                    [212, 72, 66], [245, 125, 21], [250, 193, 39], [252, 255, 164]
                ];
                return interpolateColor(colors, t);
            },
            magma: (t) => {
                const colors = [
                    [0, 0, 4], [28, 16, 68], [79, 18, 123], [129, 37, 129],
                    [181, 54, 122], [229, 80, 100], [251, 135, 97], [254, 194, 135],
                    [252, 253, 191]
                ];
                return interpolateColor(colors, t);
            },
            hot: (t) => {
                if (t < 0.33) return [255 * (t / 0.33), 0, 0];
                if (t < 0.66) return [255, 255 * ((t - 0.33) / 0.33), 0];
                return [255, 255, 255 * ((t - 0.66) / 0.34)];
            },
            cool: (t) => {
                return [255 * t, 255 * (1 - t), 255];
            },
            rainbow: (t) => {
                const h = t * 300;
                return hsvToRgb(h, 1, 1);
            }
        };

        function interpolateColor(colors, t) {
            const scaled = t * (colors.length - 1);
            const idx = Math.floor(scaled);
            const frac = scaled - idx;
            
            if (idx >= colors.length - 1) return colors[colors.length - 1];
            
            const c1 = colors[idx];
            const c2 = colors[idx + 1];
            
            return [
                c1[0] + (c2[0] - c1[0]) * frac,
                c1[1] + (c2[1] - c1[1]) * frac,
                c1[2] + (c2[2] - c1[2]) * frac
            ];
        }

        function hsvToRgb(h, s, v) {
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;
            
            let r, g, b;
            if (h < 60) [r, g, b] = [c, x, 0];
            else if (h < 120) [r, g, b] = [x, c, 0];
            else if (h < 180) [r, g, b] = [0, c, x];
            else if (h < 240) [r, g, b] = [0, x, c];
            else if (h < 300) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];
            
            return [(r + m) * 255, (g + m) * 255, (b + m) * 255];
        }

        // FFT 함수
        function performFFT(signal, fftSize) {
            const real = new Float32Array(fftSize);
            const imag = new Float32Array(fftSize);
            
            for (let i = 0; i < Math.min(signal.length, fftSize); i++) {
                real[i] = signal[i];
            }
            
            fft(real, imag);
            
            const magnitude = new Float32Array(fftSize / 2);
            for (let i = 0; i < fftSize / 2; i++) {
                magnitude[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
            }
            
            return magnitude;
        }

        function fft(real, imag) {
            const n = real.length;
            if (n <= 1) return;
            
            // Bit-reversal
            let j = 0;
            for (let i = 0; i < n; i++) {
                if (i < j) {
                    [real[i], real[j]] = [real[j], real[i]];
                    [imag[i], imag[j]] = [imag[j], imag[i]];
                }
                let k = n / 2;
                while (k <= j) {
                    j -= k;
                    k /= 2;
                }
                j += k;
            }
            
            // Cooley-Tukey FFT
            for (let size = 2; size <= n; size *= 2) {
                const halfsize = size / 2;
                const tablestep = n / size;
                for (let i = 0; i < n; i += size) {
                    for (let j = i, k = 0; j < i + halfsize; j++, k += tablestep) {
                        const angle = -2 * Math.PI * k / n;
                        const tpre = real[j + halfsize] * Math.cos(angle) - imag[j + halfsize] * Math.sin(angle);
                        const tpim = real[j + halfsize] * Math.sin(angle) + imag[j + halfsize] * Math.cos(angle);
                        real[j + halfsize] = real[j] - tpre;
                        imag[j + halfsize] = imag[j] - tpim;
                        real[j] += tpre;
                        imag[j] += tpim;
                    }
                }
            }
        }

        // 멜 스케일 변환
        function hzToMel(hz) {
            return 2595 * Math.log10(1 + hz / 700);
        }

        function melToHz(mel) {
            return 700 * (Math.pow(10, mel / 2595) - 1);
        }

        // 스펙트로그램 생성
        generateBtn.addEventListener('click', () => {
            if (!audioBuffer) {
                alert('먼저 오디오를 로드하세요!');
                return;
            }

            const fftSize = parseInt(document.getElementById('fftSize').value);
            const colormap = document.getElementById('colormap').value;
            const spectrogramType = document.getElementById('spectrogramType').value;
            const minFreq = parseInt(document.getElementById('minFreq').value);
            const maxFreq = parseInt(document.getElementById('maxFreq').value);
            const imageWidth = parseInt(document.getElementById('imageWidth').value);

            generateBtn.disabled = true;
            generateBtn.textContent = '⏳ 생성 중...';

            setTimeout(() => {
                generateSpectrogram(fftSize, colormap, spectrogramType, minFreq, maxFreq, imageWidth);
                generateBtn.disabled = false;
                generateBtn.textContent = '✨ 스펙트로그램 생성';
                downloadBtn.disabled = false;
            }, 100);
        });

        function generateSpectrogram(fftSize, colormap, spectrogramType, minFreq, maxFreq, imageWidth) {
            const channelData = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const hopSize = Math.floor(fftSize / 4);
            
            const numFrames = Math.floor((channelData.length - fftSize) / hopSize);
            const spectrogram = [];

            // 각 프레임에 대해 FFT 수행
            for (let i = 0; i < numFrames; i++) {
                const start = i * hopSize;
                const frame = channelData.slice(start, start + fftSize);
                
                // 해밍 윈도우 적용
                const windowed = new Float32Array(fftSize);
                for (let j = 0; j < fftSize; j++) {
                    windowed[j] = frame[j] * (0.54 - 0.46 * Math.cos(2 * Math.PI * j / (fftSize - 1)));
                }
                
                const magnitude = performFFT(windowed, fftSize);
                spectrogram.push(magnitude);
            }

            // 주파수 범위 계산
            const freqResolution = sampleRate / fftSize;
            const minBin = Math.floor(minFreq / freqResolution);
            const maxBin = Math.min(Math.floor(maxFreq / freqResolution), fftSize / 2);
            const numBins = maxBin - minBin;

            // 캔버스 설정
            canvas.width = imageWidth;
            canvas.height = 800;

            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            // 스펙트로그램 타입에 따라 변환
            let transformedSpec;
            if (spectrogramType === 'mel') {
                transformedSpec = applyMelScale(spectrogram, minBin, maxBin, sampleRate, fftSize);
            } else if (spectrogramType === 'log') {
                transformedSpec = applyLogScale(spectrogram, minBin, maxBin);
            } else {
                transformedSpec = spectrogram.map(frame => 
                    Array.from(frame.slice(minBin, maxBin))
                );
            }

            // 정규화
            let maxVal = -Infinity;
            transformedSpec.forEach(frame => {
                frame.forEach(val => {
                    if (val > maxVal) maxVal = val;
                });
            });

            // 이미지 생성
            for (let x = 0; x < canvas.width; x++) {
                const frameIdx = Math.floor(x / canvas.width * transformedSpec.length);
                if (frameIdx >= transformedSpec.length) continue;
                
                const frame = transformedSpec[frameIdx];
                
                for (let y = 0; y < canvas.height; y++) {
                    const binIdx = Math.floor((canvas.height - y - 1) / canvas.height * frame.length);
                    if (binIdx >= frame.length) continue;
                    
                    let val = frame[binIdx];
                    
                    // dB 스케일 적용
                    val = 20 * Math.log10(val / maxVal + 1e-10);
                    val = (val + 80) / 80; // -80dB ~ 0dB 범위를 0~1로
                    val = Math.max(0, Math.min(1, val));
                    
                    const color = colormaps[colormap](val);
                    const idx = (y * canvas.width + x) * 4;
                    
                    data[idx] = color[0];
                    data[idx + 1] = color[1];
                    data[idx + 2] = color[2];
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function applyMelScale(spectrogram, minBin, maxBin, sampleRate, fftSize) {
            const numMelBins = 128;
            const minMel = hzToMel(minBin * sampleRate / fftSize);
            const maxMel = hzToMel(maxBin * sampleRate / fftSize);
            
            const melBins = [];
            for (let i = 0; i < numMelBins; i++) {
                const mel = minMel + (maxMel - minMel) * i / (numMelBins - 1);
                const hz = melToHz(mel);
                melBins.push(Math.floor(hz * fftSize / sampleRate));
            }

            return spectrogram.map(frame => {
                const melFrame = new Array(numMelBins).fill(0);
                for (let i = 0; i < numMelBins - 1; i++) {
                    const startBin = melBins[i];
                    const endBin = melBins[i + 1];
                    let sum = 0;
                    for (let j = startBin; j < endBin && j < frame.length; j++) {
                        sum += frame[j];
                    }
                    melFrame[i] = sum / (endBin - startBin);
                }
                return melFrame;
            });
        }

        function applyLogScale(spectrogram, minBin, maxBin) {
            const numLogBins = 100;
            const logMin = Math.log(minBin + 1);
            const logMax = Math.log(maxBin + 1);
            
            return spectrogram.map(frame => {
                const logFrame = new Array(numLogBins).fill(0);
                for (let i = 0; i < numLogBins; i++) {
                    const logVal = logMin + (logMax - logMin) * i / (numLogBins - 1);
                    const bin = Math.floor(Math.exp(logVal)) - 1;
                    if (bin >= 0 && bin < frame.length) {
                        logFrame[i] = frame[bin];
                    }
                }
                return logFrame;
            });
        }

        // 다운로드 기능
        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `spectrogram_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
    </script>
</body>
</html>
